# PAKE Authentication

PAKE authentication enables an authenticator to prove knowledge of a password to
the CA without revealing the password. The authenticator uses the
[OPAQUE protocol](https://tools.ietf.org/html/draft-krawczyk-cfrg-opaque-00) but
without the key derivation functionality in order to retrieve an encrypted
private key that is stored with the server.

## Registration

To run OPAQUE, the authenticator needs to run a registration step. It first
obtains the CA's public key, `pubS` and a salt `kU`.

The salt a random value that is unique (independently generated by the server)
for each user.

Then the CA calculates:

```
vU = g^kU
```

where `g` is a public parameter (a generator).

The authenticator and CA then run an oblivious pseudorandom function (OPRF) that
takes as input `kU` from the CA and the `master password` from the
authenticator, generating a randomized password `rwdU` for the authenticator.

Next, the authenticator generates a public/private keypair, `pubU`, `privU` and
then uses authenticated encryption to calculate:

```
envU =AuthEnc(rwdU; privU, pubU, pubS, vU)
```

Here, `AuthEnc` is an authenticated encryption function, such as HMAC with an
output of 256 or more bits.

Finally, the authenticator sends `envU` and `pubU` to the CA and erases `pwdU`,
`rwdU`, `privU`, and `pubU`. The server stores `envU`, `pubU`, `kU`, and `vU` in
a record for that user.

### Retrieving the Salt

The authenticator registers a username and retrieves the CA's public key and
salt:

#### authenticator -> CA

| Method | Path                 | Arguments |
| ------ | -------------------- | --------- |
| POST   | /la0.2/pake/register | username  |

The potential responses are:

- 200 OK : success, with the body containing `pubS` and `kU`
- 403 Forbidden: username already exists

### OPRF

The authenticator chooses a random `r` in `[0..q-1]` and calculates:

```
a = H'(x)\*g^r
```

where `G` is a cyclic group of prime order `q`, `g` is a generator of G, and
`H'` is a hash function that maps abitrary strings into `G`. It then sends `a`
to the CA:

#### authenticator -> CA

| Method | Path             | Arguments |
| ------ | ---------------- | --------- |
| POST   | /la0.2/pake/oprf | a         |

The CA calculates:

```
v = g^k
b =a^k
```

where `k` is a a unique key, denoted `kU` above. The CA returns these values to
the authenticator:

- 200 OK: body includes `v` and `b`

The authenticator must first check that `a`, `b`, and `v` are non-unit elements
in G, and abort sif they are not. The authenticator can now set the output of
the OPRF, `rwdU`:

```
rwdU =H(x, v, b*v^{-r})
```

where `H` is SHA2 or SHA3 and `x` is the `master password`.

## Logging In

TBD
